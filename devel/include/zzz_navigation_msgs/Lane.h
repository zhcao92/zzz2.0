// Generated by gencpp from file zzz_navigation_msgs/Lane.msg
// DO NOT EDIT!


#ifndef ZZZ_NAVIGATION_MSGS_MESSAGE_LANE_H
#define ZZZ_NAVIGATION_MSGS_MESSAGE_LANE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <zzz_navigation_msgs/LanePoint.h>
#include <zzz_navigation_msgs/LaneBoundary.h>
#include <zzz_navigation_msgs/LaneBoundary.h>
#include <zzz_navigation_msgs/LaneSituation.h>

namespace zzz_navigation_msgs
{
template <class ContainerAllocator>
struct Lane_
{
  typedef Lane_<ContainerAllocator> Type;

  Lane_()
    : index(0)
    , speed_limit(0.0)
    , length(0.0)
    , width(0.0)
    , bidirectional(false)
    , stop_state(0)
    , central_path_points()
    , central_path_coeffs()
    , central_path_type(0)
    , left_boundaries()
    , right_boundaries()
    , situations()
    , traffic_light_pos()  {
    }
  Lane_(const ContainerAllocator& _alloc)
    : index(0)
    , speed_limit(0.0)
    , length(0.0)
    , width(0.0)
    , bidirectional(false)
    , stop_state(0)
    , central_path_points(_alloc)
    , central_path_coeffs(_alloc)
    , central_path_type(0)
    , left_boundaries(_alloc)
    , right_boundaries(_alloc)
    , situations(_alloc)
    , traffic_light_pos(_alloc)  {
  (void)_alloc;
    }



   typedef int16_t _index_type;
  _index_type index;

   typedef float _speed_limit_type;
  _speed_limit_type speed_limit;

   typedef float _length_type;
  _length_type length;

   typedef float _width_type;
  _width_type width;

   typedef uint8_t _bidirectional_type;
  _bidirectional_type bidirectional;

   typedef uint8_t _stop_state_type;
  _stop_state_type stop_state;

   typedef std::vector< ::zzz_navigation_msgs::LanePoint_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::zzz_navigation_msgs::LanePoint_<ContainerAllocator> >::other >  _central_path_points_type;
  _central_path_points_type central_path_points;

   typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _central_path_coeffs_type;
  _central_path_coeffs_type central_path_coeffs;

   typedef uint8_t _central_path_type_type;
  _central_path_type_type central_path_type;

   typedef std::vector< ::zzz_navigation_msgs::LaneBoundary_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::zzz_navigation_msgs::LaneBoundary_<ContainerAllocator> >::other >  _left_boundaries_type;
  _left_boundaries_type left_boundaries;

   typedef std::vector< ::zzz_navigation_msgs::LaneBoundary_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::zzz_navigation_msgs::LaneBoundary_<ContainerAllocator> >::other >  _right_boundaries_type;
  _right_boundaries_type right_boundaries;

   typedef std::vector< ::zzz_navigation_msgs::LaneSituation_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::zzz_navigation_msgs::LaneSituation_<ContainerAllocator> >::other >  _situations_type;
  _situations_type situations;

   typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _traffic_light_pos_type;
  _traffic_light_pos_type traffic_light_pos;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(STOP_STATE_UNKNOWN)
  #undef STOP_STATE_UNKNOWN
#endif
#if defined(_WIN32) && defined(STOP_STATE_THRU)
  #undef STOP_STATE_THRU
#endif
#if defined(_WIN32) && defined(STOP_STATE_YIELD)
  #undef STOP_STATE_YIELD
#endif
#if defined(_WIN32) && defined(STOP_STATE_STOP)
  #undef STOP_STATE_STOP
#endif
#if defined(_WIN32) && defined(STOP_STATE_STOP_YIELD)
  #undef STOP_STATE_STOP_YIELD
#endif
#if defined(_WIN32) && defined(STOP_STATE_STOP_YIELD_ALL_WAY)
  #undef STOP_STATE_STOP_YIELD_ALL_WAY
#endif
#if defined(_WIN32) && defined(CENTRAL_PATH_WAYPOINT)
  #undef CENTRAL_PATH_WAYPOINT
#endif
#if defined(_WIN32) && defined(CENTRAL_PATH_LINE)
  #undef CENTRAL_PATH_LINE
#endif
#if defined(_WIN32) && defined(CENTRAL_PATH_CONIC)
  #undef CENTRAL_PATH_CONIC
#endif
#if defined(_WIN32) && defined(CENTRAL_PATH_POLYNOMIAL)
  #undef CENTRAL_PATH_POLYNOMIAL
#endif
#if defined(_WIN32) && defined(CENTRAL_PATH_BEZIER)
  #undef CENTRAL_PATH_BEZIER
#endif

  enum {
    STOP_STATE_UNKNOWN = 0u,
    STOP_STATE_THRU = 1u,
    STOP_STATE_YIELD = 2u,
    STOP_STATE_STOP = 3u,
    STOP_STATE_STOP_YIELD = 4u,
    STOP_STATE_STOP_YIELD_ALL_WAY = 5u,
    CENTRAL_PATH_WAYPOINT = 0u,
    CENTRAL_PATH_LINE = 1u,
    CENTRAL_PATH_CONIC = 2u,
    CENTRAL_PATH_POLYNOMIAL = 3u,
    CENTRAL_PATH_BEZIER = 4u,
  };


  typedef boost::shared_ptr< ::zzz_navigation_msgs::Lane_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::zzz_navigation_msgs::Lane_<ContainerAllocator> const> ConstPtr;

}; // struct Lane_

typedef ::zzz_navigation_msgs::Lane_<std::allocator<void> > Lane;

typedef boost::shared_ptr< ::zzz_navigation_msgs::Lane > LanePtr;
typedef boost::shared_ptr< ::zzz_navigation_msgs::Lane const> LaneConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::zzz_navigation_msgs::Lane_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::zzz_navigation_msgs::Lane_<ContainerAllocator1> & lhs, const ::zzz_navigation_msgs::Lane_<ContainerAllocator2> & rhs)
{
  return lhs.index == rhs.index &&
    lhs.speed_limit == rhs.speed_limit &&
    lhs.length == rhs.length &&
    lhs.width == rhs.width &&
    lhs.bidirectional == rhs.bidirectional &&
    lhs.stop_state == rhs.stop_state &&
    lhs.central_path_points == rhs.central_path_points &&
    lhs.central_path_coeffs == rhs.central_path_coeffs &&
    lhs.central_path_type == rhs.central_path_type &&
    lhs.left_boundaries == rhs.left_boundaries &&
    lhs.right_boundaries == rhs.right_boundaries &&
    lhs.situations == rhs.situations &&
    lhs.traffic_light_pos == rhs.traffic_light_pos;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::zzz_navigation_msgs::Lane_<ContainerAllocator1> & lhs, const ::zzz_navigation_msgs::Lane_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace zzz_navigation_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::zzz_navigation_msgs::Lane_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::zzz_navigation_msgs::Lane_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::zzz_navigation_msgs::Lane_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5cbd728e4b6ec4ecaad9c99fca2ccf56";
  }

  static const char* value(const ::zzz_navigation_msgs::Lane_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5cbd728e4b6ec4ecULL;
  static const uint64_t static_value2 = 0xaad9c99fca2ccf56ULL;
};

template<class ContainerAllocator>
struct DataType< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
{
  static const char* value()
  {
    return "zzz_navigation_msgs/Lane";
  }

  static const char* value(const ::zzz_navigation_msgs::Lane_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This message describe a lane with polyline representation\n"
"\n"
"# ----- Basic properties -----\n"
"# the rightest lane is 0, reference lane is -1\n"
"# TODO: remove this field\n"
"int16 index\n"
"\n"
"# Speed limit (km/h)\n"
"float32 speed_limit\n"
"\n"
"# Length of the lane. Provided for easy computation\n"
"float32 length\n"
"float32 width\n"
"\n"
"# Whether this lane allow two way traffic\n"
"# This can be true when the road is too narrow or in the center turning lane\n"
"bool bidirectional # = False\n"
"\n"
"# The situation when lane ends. This field could be updated with dynamic info.\n"
"uint8 stop_state # = 0\n"
"uint8 STOP_STATE_UNKNOWN = 0\n"
"uint8 STOP_STATE_THRU = 1 # e.g. drive through at lane connection, green light\n"
"uint8 STOP_STATE_YIELD = 2 # e.g. unprotected left/right turn, flashing yellow light\n"
"uint8 STOP_STATE_STOP = 3 # e.g. red light, yellow light\n"
"uint8 STOP_STATE_STOP_YIELD = 4 # e.g. stop sign, right turn at red light\n"
"uint8 STOP_STATE_STOP_YIELD_ALL_WAY = 5 # e.g. flashing red light, all way stop sign\n"
"\n"
"# ----- Central path representation -----\n"
"# The central_path_points field is used when central_path_type is waypoint.\n"
"# Otherwise, central_path_coeffs should be used\n"
"LanePoint[] central_path_points\n"
"float32[] central_path_coeffs\n"
"\n"
"uint8 central_path_type # = 0\n"
"uint8 CENTRAL_PATH_WAYPOINT = 0 # discretized\n"
"uint8 CENTRAL_PATH_LINE = 1\n"
"uint8 CENTRAL_PATH_CONIC = 2 # conic section, including parabola and hyperbola\n"
"uint8 CENTRAL_PATH_POLYNOMIAL = 3 #\n"
"uint8 CENTRAL_PATH_BEZIER = 4\n"
"\n"
"# ----- Boundary representation -----\n"
"# The boundary description of current lane.\n"
"# Not that the boundary type only describe the behaviour from current lane to neighbour lane or road shoulder\n"
"LaneBoundary[] left_boundaries\n"
"LaneBoundary[] right_boundaries\n"
"\n"
"# ----- Auxiliary information of the lane -----\n"
"# Road situations on this line. This field could be updated with dynamic info.\n"
"LaneSituation[] situations\n"
"\n"
"# ---- traffic ligth position ------ \n"
"float32[] traffic_light_pos\n"
"================================================================================\n"
"MSG: zzz_navigation_msgs/LanePoint\n"
"# This message describe a road point from polyline represented lane\n"
"\n"
"# The 3D position of the lane point\n"
"geometry_msgs/Point position\n"
"\n"
"# ----- Other useful information -----\n"
"# Distance from lane start to current point. The distance of the first point should be zero\n"
"float32 s\n"
"\n"
"# Slope at current position of the road\n"
"# Can be used to control the throttle\n"
"float32 slope\n"
"\n"
"# Road curvature at current position of the road\n"
"# Can be used to slow down before turning\n"
"float32 curvature\n"
"\n"
"# The yaw angle of tangent line (in radian)\n"
"float32 tangent\n"
"\n"
"# Road width at current position\n"
"# Can be used to determine the carefulness of driving\n"
"float32 width\n"
"\n"
"================================================================================\n"
"MSG: geometry_msgs/Point\n"
"# This contains the position of a point in free space\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
"\n"
"================================================================================\n"
"MSG: zzz_navigation_msgs/LaneBoundary\n"
"# This message describe the boundary type of a part of a lane\n"
"\n"
"# Lane boundary point\n"
"LanePoint boundary_point\n"
"\n"
"# Boundary type from between `s` and `s` of the next section start\n"
"uint8 boundary_type\n"
"uint8 BOUNDARY_UNKNOWN = 0\n"
"uint8 BOUNDARY_DASHED_WHITE = 1  # neighbour lane has same direction.\n"
"uint8 BOUNDARY_DASHED_YELLOW = 2 # neighbour lane has different direction.\n"
"uint8 BOUNDARY_SOLID_WHITE = 3   # neighbour lane has same direction, not allowed to change lane.\n"
"uint8 BOUNDARY_SOLID_YELLOW = 4  # neighbour lane has different direction, not allowed to change lane.\n"
"uint8 BOUNDARY_SOLID_YELLOW_TURN = 5  # neighbour lane has different direction, not allowed to change lane unless turning.\n"
"uint8 BOUNDARY_CURB = 6          # neighbour is road shoulder\n"
"\n"
"# Confidence of the lane boundary classification\n"
"float32 confidence\n"
"\n"
"================================================================================\n"
"MSG: zzz_navigation_msgs/LaneSituation\n"
"# This message store any uncommon situations on a road\n"
"# Situation can be a map specified object or fresh events\n"
"\n"
"# The location of the situation in a lane (distance from lane start)\n"
"float32 s\n"
"\n"
"# How long this situation affect along the lane.\n"
"# Inf means take effect until lane ends\n"
"float32 length\n"
"\n"
"# Type of situation\n"
"uint8 situation_type\n"
"uint8 SITUATION_NOT_SPECIFIED = 0\n"
"uint8 SITUATION_BLOCKED = 1 # Something blocked this lane, vehicle should stop here\n"
"uint8 SITUATION_CROSSWALK = 2 # Crosswalk\n"
"uint8 SITUATION_REDUCE_SPEED = 3 # Reducing speed is required. This can be due to speed bump, construction, or school bus stop, etc\n"
"\n"
"# ------- Situation information -------\n"
"# The new speed limit. Zero means the vehicle is required to stop\n"
"float32 reduced_max_speed\n"
"\n"
"# Additional information\n"
"string comments\n"
;
  }

  static const char* value(const ::zzz_navigation_msgs::Lane_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.index);
      stream.next(m.speed_limit);
      stream.next(m.length);
      stream.next(m.width);
      stream.next(m.bidirectional);
      stream.next(m.stop_state);
      stream.next(m.central_path_points);
      stream.next(m.central_path_coeffs);
      stream.next(m.central_path_type);
      stream.next(m.left_boundaries);
      stream.next(m.right_boundaries);
      stream.next(m.situations);
      stream.next(m.traffic_light_pos);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Lane_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::zzz_navigation_msgs::Lane_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::zzz_navigation_msgs::Lane_<ContainerAllocator>& v)
  {
    s << indent << "index: ";
    Printer<int16_t>::stream(s, indent + "  ", v.index);
    s << indent << "speed_limit: ";
    Printer<float>::stream(s, indent + "  ", v.speed_limit);
    s << indent << "length: ";
    Printer<float>::stream(s, indent + "  ", v.length);
    s << indent << "width: ";
    Printer<float>::stream(s, indent + "  ", v.width);
    s << indent << "bidirectional: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bidirectional);
    s << indent << "stop_state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.stop_state);
    s << indent << "central_path_points[]" << std::endl;
    for (size_t i = 0; i < v.central_path_points.size(); ++i)
    {
      s << indent << "  central_path_points[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::zzz_navigation_msgs::LanePoint_<ContainerAllocator> >::stream(s, indent + "    ", v.central_path_points[i]);
    }
    s << indent << "central_path_coeffs[]" << std::endl;
    for (size_t i = 0; i < v.central_path_coeffs.size(); ++i)
    {
      s << indent << "  central_path_coeffs[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.central_path_coeffs[i]);
    }
    s << indent << "central_path_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.central_path_type);
    s << indent << "left_boundaries[]" << std::endl;
    for (size_t i = 0; i < v.left_boundaries.size(); ++i)
    {
      s << indent << "  left_boundaries[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::zzz_navigation_msgs::LaneBoundary_<ContainerAllocator> >::stream(s, indent + "    ", v.left_boundaries[i]);
    }
    s << indent << "right_boundaries[]" << std::endl;
    for (size_t i = 0; i < v.right_boundaries.size(); ++i)
    {
      s << indent << "  right_boundaries[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::zzz_navigation_msgs::LaneBoundary_<ContainerAllocator> >::stream(s, indent + "    ", v.right_boundaries[i]);
    }
    s << indent << "situations[]" << std::endl;
    for (size_t i = 0; i < v.situations.size(); ++i)
    {
      s << indent << "  situations[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::zzz_navigation_msgs::LaneSituation_<ContainerAllocator> >::stream(s, indent + "    ", v.situations[i]);
    }
    s << indent << "traffic_light_pos[]" << std::endl;
    for (size_t i = 0; i < v.traffic_light_pos.size(); ++i)
    {
      s << indent << "  traffic_light_pos[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.traffic_light_pos[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // ZZZ_NAVIGATION_MSGS_MESSAGE_LANE_H
