// Generated by gencpp from file zzz_perception_msgs/ObjectSignals.msg
// DO NOT EDIT!


#ifndef ZZZ_PERCEPTION_MSGS_MESSAGE_OBJECTSIGNALS_H
#define ZZZ_PERCEPTION_MSGS_MESSAGE_OBJECTSIGNALS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace zzz_perception_msgs
{
template <class ContainerAllocator>
struct ObjectSignals_
{
  typedef ObjectSignals_<ContainerAllocator> Type;

  ObjectSignals_()
    : flags(0)
    , score(0.0)  {
    }
  ObjectSignals_(const ContainerAllocator& _alloc)
    : flags(0)
    , score(0.0)  {
  (void)_alloc;
    }



   typedef uint16_t _flags_type;
  _flags_type flags;

   typedef float _score_type;
  _score_type score;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(UNKNOWN)
  #undef UNKNOWN
#endif
#if defined(_WIN32) && defined(NONE)
  #undef NONE
#endif
#if defined(_WIN32) && defined(VEHICLE_SIGNAL)
  #undef VEHICLE_SIGNAL
#endif
#if defined(_WIN32) && defined(VEHICLE_SIGNAL_LEFT_TURN)
  #undef VEHICLE_SIGNAL_LEFT_TURN
#endif
#if defined(_WIN32) && defined(VEHICLE_SIGNAL_RIGHT_TURN)
  #undef VEHICLE_SIGNAL_RIGHT_TURN
#endif
#if defined(_WIN32) && defined(VEHICLE_SIGNAL_HAZARD)
  #undef VEHICLE_SIGNAL_HAZARD
#endif
#if defined(_WIN32) && defined(VEHICLE_SIGNAL_BRAKE)
  #undef VEHICLE_SIGNAL_BRAKE
#endif
#if defined(_WIN32) && defined(VEHICLE_SIGNAL_REVERSE)
  #undef VEHICLE_SIGNAL_REVERSE
#endif
#if defined(_WIN32) && defined(VEHICLE_SIGNAL_SPEED_30_LIMIT)
  #undef VEHICLE_SIGNAL_SPEED_30_LIMIT
#endif
#if defined(_WIN32) && defined(TRAFFIC_LIGHT)
  #undef TRAFFIC_LIGHT
#endif
#if defined(_WIN32) && defined(TRAFFIC_LIGHT_RED)
  #undef TRAFFIC_LIGHT_RED
#endif
#if defined(_WIN32) && defined(TRAFFIC_LIGHT_YELLOW)
  #undef TRAFFIC_LIGHT_YELLOW
#endif
#if defined(_WIN32) && defined(TRAFFIC_LIGHT_GREEN)
  #undef TRAFFIC_LIGHT_GREEN
#endif
#if defined(_WIN32) && defined(TRAFFIC_LIGHT_GREEN_LEFT_TURN)
  #undef TRAFFIC_LIGHT_GREEN_LEFT_TURN
#endif
#if defined(_WIN32) && defined(TRAFFIC_LIGHT_GREEN_RIGHT_TURN)
  #undef TRAFFIC_LIGHT_GREEN_RIGHT_TURN
#endif

  enum {
    UNKNOWN = 0u,
    NONE = 16u,
    VEHICLE_SIGNAL = 1u,
    VEHICLE_SIGNAL_LEFT_TURN = 17u,
    VEHICLE_SIGNAL_RIGHT_TURN = 33u,
    VEHICLE_SIGNAL_HAZARD = 49u,
    VEHICLE_SIGNAL_BRAKE = 65u,
    VEHICLE_SIGNAL_REVERSE = 81u,
    VEHICLE_SIGNAL_SPEED_30_LIMIT = 97u,
    TRAFFIC_LIGHT = 2u,
    TRAFFIC_LIGHT_RED = 18u,
    TRAFFIC_LIGHT_YELLOW = 34u,
    TRAFFIC_LIGHT_GREEN = 50u,
    TRAFFIC_LIGHT_GREEN_LEFT_TURN = 66u,
    TRAFFIC_LIGHT_GREEN_RIGHT_TURN = 66u,
  };


  typedef boost::shared_ptr< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> const> ConstPtr;

}; // struct ObjectSignals_

typedef ::zzz_perception_msgs::ObjectSignals_<std::allocator<void> > ObjectSignals;

typedef boost::shared_ptr< ::zzz_perception_msgs::ObjectSignals > ObjectSignalsPtr;
typedef boost::shared_ptr< ::zzz_perception_msgs::ObjectSignals const> ObjectSignalsConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator1> & lhs, const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator2> & rhs)
{
  return lhs.flags == rhs.flags &&
    lhs.score == rhs.score;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator1> & lhs, const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace zzz_perception_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
{
  static const char* value()
  {
    return "a7911e45a2280b3764131391e149fc54";
  }

  static const char* value(const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xa7911e45a2280b37ULL;
  static const uint64_t static_value2 = 0x64131391e149fc54ULL;
};

template<class ContainerAllocator>
struct DataType< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
{
  static const char* value()
  {
    return "zzz_perception_msgs/ObjectSignals";
  }

  static const char* value(const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This message is used to represent detected vehicle light signals or human hand signals\n"
"\n"
"# Signal flags. Multiple signal emission can exists in the same time.\n"
"uint16 flags\n"
"\n"
"uint16 UNKNOWN                          = 0     # 0x00\n"
"uint16 NONE                             = 16    # 0x10\n"
"\n"
"# This field is related to https://en.wikipedia.org/wiki/Automotive_lighting\n"
"uint16 VEHICLE_SIGNAL                   = 1     # 0x01\n"
"uint16 VEHICLE_SIGNAL_LEFT_TURN         = 17    # 0x11\n"
"uint16 VEHICLE_SIGNAL_RIGHT_TURN        = 33    # 0x21\n"
"uint16 VEHICLE_SIGNAL_HAZARD            = 49    # 0x31\n"
"uint16 VEHICLE_SIGNAL_BRAKE             = 65    # 0x41\n"
"uint16 VEHICLE_SIGNAL_REVERSE           = 81    # 0x51\n"
"uint16 VEHICLE_SIGNAL_SPEED_30_LIMIT    = 97    # 0x61\n"
"\n"
"# This field is related to https://en.wikipedia.org/wiki/Traffic_light#Single_aspects\n"
"uint16 TRAFFIC_LIGHT                    = 2     # 0x02\n"
"uint16 TRAFFIC_LIGHT_RED                = 18    # 0x12\n"
"uint16 TRAFFIC_LIGHT_YELLOW             = 34    # 0x22\n"
"uint16 TRAFFIC_LIGHT_GREEN              = 50    # 0x32\n"
"uint16 TRAFFIC_LIGHT_GREEN_LEFT_TURN    = 66    # 0x42\n"
"uint16 TRAFFIC_LIGHT_GREEN_RIGHT_TURN   = 66    # 0x42\n"
"\n"
"# Confidence of the signal detection\n"
"float32 score\n"
;
  }

  static const char* value(const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.flags);
      stream.next(m.score);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ObjectSignals_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::zzz_perception_msgs::ObjectSignals_<ContainerAllocator>& v)
  {
    s << indent << "flags: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.flags);
    s << indent << "score: ";
    Printer<float>::stream(s, indent + "  ", v.score);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ZZZ_PERCEPTION_MSGS_MESSAGE_OBJECTSIGNALS_H
